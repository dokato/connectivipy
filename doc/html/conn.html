
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Connectivity &#8212; ConnectiviPy 0.3.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/agogo.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Mvarmodel" href="mvar.html" />
    <link rel="prev" title="Data" href="data.html" /> 
  </head><body>
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="index.html">ConnectiviPy 0.3.7 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="data.html" title="Data"
             accesskey="P">previous</a> |
          <a href="mvar.html" title="Mvarmodel"
             accesskey="N">next</a> |
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="connectivity">
<span id="conn"></span><h1>Connectivity<a class="headerlink" href="#connectivity" title="Permalink to this headline">¶</a></h1>
<p>Connectivity methods classes.</p>
<span class="target" id="module-connectivipy.conn"></span><dl class="py function">
<dt class="sig sig-object py" id="connectivipy.conn.spectrum">
<span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">acoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vcoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#spectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating data point from matrix <em>A</em> with MVAR coefficients.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>acoef</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</p>
</dd>
<dt><em>vcoef</em><span class="classifier">numpy.array</span></dt><dd><p>prediction error matrix (k, k)</p>
</dd>
<dt><em>fs</em> = 1<span class="classifier">int</span></dt><dd><p>sampling rate</p>
</dd>
<dt><em>resolution</em> = 100<span class="classifier">int</span></dt><dd><p>number of spectrum data points</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>A_z</em><span class="classifier">numpy.array</span></dt><dd><p>z-transformed A(f) complex matrix in shape (<em>resolution</em>, k, k)</p>
</dd>
<dt><em>H_z</em><span class="classifier">numpy.array</span></dt><dd><p>inversion of <em>A_z</em></p>
</dd>
<dt><em>S_z</em><span class="classifier">numpy.array</span></dt><dd><p>spectrum matrix (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] K. J. Blinowska, R. Kus, M. Kaminski (2004) “Granger causality</p>
<blockquote>
<div><p>and information flow in multivariate processes”
Physical Review E 70, 050902.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">acoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vcoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#spectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating data point from matrix <em>A</em> with MVAR coefficients.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>acoef</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</p>
</dd>
<dt><em>vcoef</em><span class="classifier">numpy.array</span></dt><dd><p>prediction error matrix (k, k)</p>
</dd>
<dt><em>fs</em> = 1<span class="classifier">int</span></dt><dd><p>sampling rate</p>
</dd>
<dt><em>resolution</em> = 100<span class="classifier">int</span></dt><dd><p>number of spectrum data points</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>A_z</em><span class="classifier">numpy.array</span></dt><dd><p>z-transformed A(f) complex matrix in shape (<em>resolution</em>, k, k)</p>
</dd>
<dt><em>H_z</em><span class="classifier">numpy.array</span></dt><dd><p>inversion of <em>A_z</em></p>
</dd>
<dt><em>S_z</em><span class="classifier">numpy.array</span></dt><dd><p>spectrum matrix (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] K. J. Blinowska, R. Kus, M. Kaminski (2004) “Granger causality</p>
<blockquote>
<div><p>and information flow in multivariate processes”
Physical Review E 70, 050902.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="connectivipy.conn.spectrum_inst">
<span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">spectrum_inst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">acoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vcoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#spectrum_inst"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.spectrum_inst" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating data point from matrix <em>A</em> with MVAR coefficients taking
into account zero-lag effects.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>acoef</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, k, p+1) where <em>k</em> is number of channels and
<em>p</em> is a model order. acoef[0] - is (k, k) matrix for zero lag,
acoef[1] for one data point lag and so on.</p>
</dd>
<dt><em>vcoef</em><span class="classifier">numpy.array</span></dt><dd><p>prediction error matrix (k, k)</p>
</dd>
<dt><em>fs</em> = 1<span class="classifier">int</span></dt><dd><p>sampling rate</p>
</dd>
<dt><em>resolution</em> = 100<span class="classifier">int</span></dt><dd><p>number of spectrum data points</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>A_z</em><span class="classifier">numpy.array</span></dt><dd><p>z-transformed A(f) complex matrix in shape (<em>resolution</em>, k, k)</p>
</dd>
<dt><em>H_z</em><span class="classifier">numpy.array</span></dt><dd><p>inversion of <em>A_z</em></p>
</dd>
<dt><em>S_z</em><span class="classifier">numpy.array</span></dt><dd><p>spectrum matrix (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Erla S. et all, Multivariate Autoregressive Model with</p>
<blockquote>
<div><p>Instantaneous Effects to Improve Brain Connectivity Estimation,
Int. J. Bioelectromagn. 11, 74–79 (2009).</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id1">
<span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">spectrum_inst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">acoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vcoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#spectrum_inst"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id1" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating data point from matrix <em>A</em> with MVAR coefficients taking
into account zero-lag effects.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>acoef</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, k, p+1) where <em>k</em> is number of channels and
<em>p</em> is a model order. acoef[0] - is (k, k) matrix for zero lag,
acoef[1] for one data point lag and so on.</p>
</dd>
<dt><em>vcoef</em><span class="classifier">numpy.array</span></dt><dd><p>prediction error matrix (k, k)</p>
</dd>
<dt><em>fs</em> = 1<span class="classifier">int</span></dt><dd><p>sampling rate</p>
</dd>
<dt><em>resolution</em> = 100<span class="classifier">int</span></dt><dd><p>number of spectrum data points</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>A_z</em><span class="classifier">numpy.array</span></dt><dd><p>z-transformed A(f) complex matrix in shape (<em>resolution</em>, k, k)</p>
</dd>
<dt><em>H_z</em><span class="classifier">numpy.array</span></dt><dd><p>inversion of <em>A_z</em></p>
</dd>
<dt><em>S_z</em><span class="classifier">numpy.array</span></dt><dd><p>spectrum matrix (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Erla S. et all, Multivariate Autoregressive Model with</p>
<blockquote>
<div><p>Instantaneous Effects to Improve Brain Connectivity Estimation,
Int. J. Bioelectromagn. 11, 74–79 (2009).</p>
</div></blockquote>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.Connect">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">Connect</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#Connect"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.Connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class governing calculation of various connectivity estimators
with concrete methods: <em>short_time</em>, <em>significance</em> and
abstract <em>calculate</em>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.Connect.calculate">
<em class="property"><span class="pre">abstract</span> </em><span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#Connect.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.Connect.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method to calculate values of estimators from specific
parameters</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.Connect.short_time">
<span class="sig-name descname"><span class="pre">short_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#Connect.short_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.Connect.short_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Short-tme version of estimator, where data is windowed into parts
of length <em>nfft</em> and overlap <em>no</em>. <em>params</em> catch additional
parameters specific for estimator.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>data matrix (kXN) or (kXNxR) where k - channels,
N - data points, R - nr of trials</p>
</dd>
<dt><em>nfft</em> = None<span class="classifier">int</span></dt><dd><p>window length (if None it’s N/5)</p>
</dd>
<dt><em>no</em> = None<span class="classifier">int</span></dt><dd><p>overlap length (if None it’s N/10)</p>
</dd>
<dt><em>params</em> :</dt><dd><p>additional parameters specific for chosen estimator</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>stvalues</em><span class="classifier">numpy.array</span></dt><dd><p>short time values (time points, frequency, k, k), where k
is number of channels</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.Connect.short_time_significance">
<span class="sig-name descname"><span class="pre">short_time_significance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#Connect.short_time_significance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.Connect.short_time_significance" title="Permalink to this definition">¶</a></dt>
<dd><p>Significance of short-tme versions of estimators. It base on
bootstrap <a class="reference internal" href="#connectivipy.conn.Connect.bootstrap" title="connectivipy.conn.Connect.bootstrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.bootstrap()</span></code></a> for multitrial case and
surrogate data <a class="reference internal" href="#connectivipy.conn.Connect.surrogate" title="connectivipy.conn.Connect.surrogate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.surrogate()</span></code></a> for one trial.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>data matrix (kXN) or (kXNxR) where k - channels,
N - data points, R - nr of trials</p>
</dd>
<dt><em>Nrep</em> = 100<span class="classifier">int</span></dt><dd><p>number of resamples</p>
</dd>
<dt><em>alpha</em> = 0.05<span class="classifier">float</span></dt><dd><p>type I error rate (significance level)</p>
</dd>
<dt><em>nfft</em> = None<span class="classifier">int</span></dt><dd><p>window length (if None it’s N/5)</p>
</dd>
<dt><em>no</em> = None<span class="classifier">int</span></dt><dd><p>overlap length (if None it’s N/10)</p>
</dd>
<dt><em>verbose</em> = True<span class="classifier">bool</span></dt><dd><p>if True it prints dot on every realization, if False it’s
quiet.</p>
</dd>
<dt><em>params</em> :</dt><dd><p>additional parameters specific for chosen estimator</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>signi_st</em><span class="classifier">numpy.array</span></dt><dd><p>short time significance values in shape of
- (tp, k, k) for one sided estimator
- (tp, 2, k, k) for two sided
where k is number of channels and tp number of time points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.Connect.significance">
<span class="sig-name descname"><span class="pre">significance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#Connect.significance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.Connect.significance" title="Permalink to this definition">¶</a></dt>
<dd><p>Significance of connectivity estimators. It base on
bootstrap <a class="reference internal" href="#connectivipy.conn.Connect.bootstrap" title="connectivipy.conn.Connect.bootstrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.bootstrap()</span></code></a> for multitrial case and
surrogate data <a class="reference internal" href="#connectivipy.conn.Connect.surrogate" title="connectivipy.conn.Connect.surrogate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.surrogate()</span></code></a> for one trial.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>data matrix (kXN) or (kXNxR) where k - channels,
N - data points, R - nr of trials</p>
</dd>
<dt><em>Nrep</em> = 100<span class="classifier">int</span></dt><dd><p>number of resamples</p>
</dd>
<dt><em>alpha</em> = 0.05<span class="classifier">float</span></dt><dd><p>type I error rate (significance level)</p>
</dd>
<dt><em>verbose</em> = True<span class="classifier">bool</span></dt><dd><p>if True it prints dot on every realization, if False it’s
quiet.</p>
</dd>
<dt><em>params</em> :</dt><dd><p>additional parameters specific for chosen estimator</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>signific</em><span class="classifier">numpy.array</span></dt><dd><p>significance values, check <a class="reference internal" href="#connectivipy.conn.Connect.levels" title="connectivipy.conn.Connect.levels"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.levels()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.Connect.levels">
<span class="sig-name descname"><span class="pre">levels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#Connect.levels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.Connect.levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Levels of significance
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>signi</em><span class="classifier">numpy.array</span></dt><dd><p>bootstraped values of each channel</p>
</dd>
<dt><em>alpha</em><span class="classifier">float</span></dt><dd><p>type I error rate (significance level) - from 0 to 1
- (1-<em>alpha</em>) for onesided estimators (e.g. class:<cite>DTF</cite>)
- <em>alpha</em> and (1-<em>alpha</em>) for twosided (e.g. class:<cite>PSI</cite>)</p>
</dd>
<dt><em>k</em><span class="classifier">int</span></dt><dd><p>number of channels</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>ficance</em><span class="classifier">numpy.array</span></dt><dd><p>maximal value throughout frequency of score at percentile
at level 1-<em>alpha</em>
- (k, k) for one sided estimator
- (2, k, k) for two sided</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.Connect.bootstrap">
<span class="sig-name descname"><span class="pre">bootstrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#Connect.bootstrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.Connect.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bootstrap - random sampling with replacement of trials.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>multichannel data matrix</p>
</dd>
<dt><em>Nrep</em> = 100<span class="classifier">int</span></dt><dd><p>number of resamples</p>
</dd>
<dt><em>alpha</em> = 0.05<span class="classifier">float</span></dt><dd><p>type I error rate (significance level)</p>
</dd>
<dt><em>verbose</em> = True<span class="classifier">bool</span></dt><dd><p>if True it prints dot on every realization, if False it’s
quiet.</p>
</dd>
<dt><em>params</em> :</dt><dd><p>additional parameters specific for chosen estimator</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>levelsigni</em><span class="classifier">numpy.array</span></dt><dd><p>significance values, check <a class="reference internal" href="#connectivipy.conn.Connect.levels" title="connectivipy.conn.Connect.levels"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.levels()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.Connect.surrogate">
<span class="sig-name descname"><span class="pre">surrogate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#Connect.surrogate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.Connect.surrogate" title="Permalink to this definition">¶</a></dt>
<dd><p>Surrogate data testing. Mixing data points in each channel.
Significance level in calculated over all <em>Nrep</em> surrogate sets.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>multichannel data matrix</p>
</dd>
<dt><em>Nrep</em> = 100<span class="classifier">int</span></dt><dd><p>number of resamples</p>
</dd>
<dt><em>alpha</em> = 0.05<span class="classifier">float</span></dt><dd><p>type I error rate (significance level)</p>
</dd>
<dt><em>verbose</em> = True<span class="classifier">bool</span></dt><dd><p>if True it prints dot on every realization, if False it’s
quiet.</p>
</dd>
<dt><em>params</em> :</dt><dd><p>additional parameters specific for chosen estimator</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>levelsigni</em><span class="classifier">numpy.array</span></dt><dd><p>significance values, check <a class="reference internal" href="#connectivipy.conn.Connect.levels" title="connectivipy.conn.Connect.levels"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.levels()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.ConnectAR">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">ConnectAR</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#ConnectAR"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.ConnectAR" title="Permalink to this definition">¶</a></dt>
<dd><p>Inherits from <em>Connect</em> class and governs calculation of various
connectivity estimators basing on MVAR model methods. It overloads
<em>short_time</em>, <em>significance</em> methods but <em>calculate</em> remains abstract.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.ConnectAR.short_time">
<span class="sig-name descname"><span class="pre">short_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mvarmethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'yw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#ConnectAR.short_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.ConnectAR.short_time" title="Permalink to this definition">¶</a></dt>
<dd><p>It overloads <a class="reference internal" href="#connectivipy.conn.ConnectAR" title="connectivipy.conn.ConnectAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectAR</span></code></a> method <a class="reference internal" href="#connectivipy.conn.Connect.short_time" title="connectivipy.conn.Connect.short_time"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.short_time()</span></code></a>.
Short-tme version of estimator, where data is windowed into parts
of length <em>nfft</em> and overlap <em>no</em>. <em>params</em> catch additional
parameters specific for estimator.
Args:</p>
<blockquote>
<div><dl>
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>data matrix (kXN) or (kXNxR) where k - channels,
N - data points, R - nr of trials</p>
</dd>
<dt><em>nfft</em> = None<span class="classifier">int</span></dt><dd><p>window length (if None it’s N/5)</p>
</dd>
<dt><em>no</em> = None<span class="classifier">int</span></dt><dd><p>overlap length (if None it’s N/10)</p>
</dd>
<dt><em>mvarmethod</em> = ‘yw’ :</dt><dd><blockquote>
<div><p>MVAR parameters estimation method</p>
</div></blockquote>
<p>all avaiable methods you can find in <em>fitting_algorithms</em></p>
</dd>
<dt><em>order</em> = None:</dt><dd><p>MVAR model order; it None, it is set automatically basing
on default criterion.</p>
</dd>
<dt><em>resol</em> = None:</dt><dd><p>frequency resolution; if None, it is 100.</p>
</dd>
<dt><em>fs</em> = 1 :</dt><dd><p>sampling frequency</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>stvalues</em><span class="classifier">numpy.array</span></dt><dd><p>short time values (time points, frequency, k, k), where k
is number of channels</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.ConnectAR.short_time_significance">
<span class="sig-name descname"><span class="pre">short_time_significance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'yw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#ConnectAR.short_time_significance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.ConnectAR.short_time_significance" title="Permalink to this definition">¶</a></dt>
<dd><p>Significance of short-tme versions of estimators. It base on
bootstrap <a class="reference internal" href="#connectivipy.conn.ConnectAR.bootstrap" title="connectivipy.conn.ConnectAR.bootstrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">ConnectAR.bootstrap()</span></code></a> for multitrial case and
surrogate data <a class="reference internal" href="#connectivipy.conn.ConnectAR.surrogate" title="connectivipy.conn.ConnectAR.surrogate"><code class="xref py py-func docutils literal notranslate"><span class="pre">ConnectAR.surrogate()</span></code></a> for one trial.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>data matrix (kXN) or (kXNxR) where k - channels,
N - data points, R - nr of trials</p>
</dd>
<dt><em>Nrep</em> = 100<span class="classifier">int</span></dt><dd><p>number of resamples</p>
</dd>
<dt><em>alpha</em> = 0.05<span class="classifier">float</span></dt><dd><p>type I error rate (significance level)</p>
</dd>
<dt><em>method</em> = ‘yw’: str</dt><dd><p>method of MVAR parameters estimation
all avaiable methods you can find in <em>fitting_algorithms</em></p>
</dd>
<dt><em>order</em> = None<span class="classifier">int</span></dt><dd><p>MVAR model order, if None, it’s chosen using default criterion</p>
</dd>
<dt><em>fs</em> = 1<span class="classifier">int</span></dt><dd><p>sampling frequency</p>
</dd>
<dt><em>resolution</em> = None<span class="classifier">int</span></dt><dd><p>resolution (if None, it’s 100 points)</p>
</dd>
<dt><em>nfft</em> = None<span class="classifier">int</span></dt><dd><p>window length (if None it’s N/5)</p>
</dd>
<dt><em>no</em> = None<span class="classifier">int</span></dt><dd><p>overlap length (if None it’s N/10)</p>
</dd>
<dt><em>verbose</em> = True<span class="classifier">bool</span></dt><dd><p>if True it prints dot on every realization, if False it’s
quiet.</p>
</dd>
<dt><em>params</em> :</dt><dd><p>additional parameters specific for chosen estimator</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>signi_st</em><span class="classifier">numpy.array</span></dt><dd><p>short time significance values in shape of
- (tp, k, k) for one sided estimator
- (tp, 2, k, k) for two sided
where k is number of channels and tp number of time points</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.ConnectAR.significance">
<span class="sig-name descname"><span class="pre">significance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#ConnectAR.significance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.ConnectAR.significance" title="Permalink to this definition">¶</a></dt>
<dd><p>Significance of connectivity estimators. It base on
bootstrap <a class="reference internal" href="#connectivipy.conn.ConnectAR.bootstrap" title="connectivipy.conn.ConnectAR.bootstrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">ConnectAR.bootstrap()</span></code></a> for multitrial case and
surrogate data <a class="reference internal" href="#connectivipy.conn.ConnectAR.surrogate" title="connectivipy.conn.ConnectAR.surrogate"><code class="xref py py-func docutils literal notranslate"><span class="pre">ConnectAR.surrogate()</span></code></a> for one trial.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>data matrix</p>
</dd>
<dt><em>method</em> = ‘yw’: str</dt><dd><p>method of MVAR parametersestimation
all avaiable methods you can find in <em>fitting_algorithms</em></p>
</dd>
<dt><em>order</em> = None<span class="classifier">int</span></dt><dd><p>MVAR model order, if None, it’s chosen using default criterion</p>
</dd>
<dt><em>Nrep</em> = 100<span class="classifier">int</span></dt><dd><p>number of resamples</p>
</dd>
<dt><em>alpha</em> = 0.05<span class="classifier">float</span></dt><dd><p>type I error rate (significance level)</p>
</dd>
<dt><em>resolution</em> = None<span class="classifier">int</span></dt><dd><p>resolution (if None, it’s 100 points)</p>
</dd>
<dt><em>verbose</em> = True<span class="classifier">bool</span></dt><dd><p>if True it prints dot on every realization, if False it’s
quiet.</p>
</dd>
<dt><em>params</em> :</dt><dd><p>additional parameters specific for chosen estimator</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>signi_st</em><span class="classifier">numpy.array</span></dt><dd><p>significance values, check <a class="reference internal" href="#connectivipy.conn.Connect.levels" title="connectivipy.conn.Connect.levels"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.levels()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.ConnectAR.bootstrap">
<span class="sig-name descname"><span class="pre">bootstrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#ConnectAR.bootstrap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.ConnectAR.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bootstrap - random sampling with replacement of trials for <em>ConnectAR</em>.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>multichannel data matrix</p>
</dd>
<dt><em>method</em><span class="classifier">str</span></dt><dd><p>method of MVAR parametersestimation
all avaiable methods you can find in <em>fitting_algorithms</em></p>
</dd>
<dt><em>Nrep</em> = 100<span class="classifier">int</span></dt><dd><p>number of resamples</p>
</dd>
<dt><em>alpha</em> = 0.05<span class="classifier">float</span></dt><dd><p>type I error rate (significance level)</p>
</dd>
<dt><em>order</em> = None<span class="classifier">int</span></dt><dd><p>MVAR model order, if None, it’s chosen using default criterion</p>
</dd>
<dt><em>verbose</em> = True<span class="classifier">bool</span></dt><dd><p>if True it prints dot on every realization, if False it’s
quiet.</p>
</dd>
<dt><em>params</em> :</dt><dd><p>additional parameters specific for chosen estimator</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>levelsigni</em><span class="classifier">numpy.array</span></dt><dd><p>significance values, check <a class="reference internal" href="#connectivipy.conn.Connect.levels" title="connectivipy.conn.Connect.levels"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.levels()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.ConnectAR.surrogate">
<span class="sig-name descname"><span class="pre">surrogate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#ConnectAR.surrogate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.ConnectAR.surrogate" title="Permalink to this definition">¶</a></dt>
<dd><p>Surrogate data testing for <em>ConnectAR</em> . Mixing data points in each channel.
Significance level in calculated over all <em>Nrep</em> surrogate sets.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>multichannel data matrix</p>
</dd>
<dt><em>method</em><span class="classifier">str</span></dt><dd><p>method of MVAR parameters estimation
all avaiable methods you can find in <em>fitting_algorithms</em></p>
</dd>
<dt><em>Nrep</em> = 100<span class="classifier">int</span></dt><dd><p>number of resamples</p>
</dd>
<dt><em>alpha</em> = 0.05<span class="classifier">float</span></dt><dd><p>type I error rate (significance level)</p>
</dd>
<dt><em>order</em> = None<span class="classifier">int</span></dt><dd><p>MVAR model order, if None, it’s chosen using default criterion</p>
</dd>
<dt><em>verbose</em> = True<span class="classifier">bool</span></dt><dd><p>if True it prints dot on every realization, if False it’s
quiet.</p>
</dd>
<dt><em>params</em> :</dt><dd><p>additional parameters specific for chosen estimator</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>levelsigni</em><span class="classifier">numpy.array</span></dt><dd><p>significance values, check <a class="reference internal" href="#connectivipy.conn.Connect.levels" title="connectivipy.conn.Connect.levels"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.levels()</span></code></a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="connectivipy.conn.dtf_fun">
<span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">dtf_fun</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Acoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vcoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#dtf_fun"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.dtf_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Directed Transfer Function estimation from MVAR parameters.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>Acoef</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</p>
</dd>
<dt><em>Vcoef</em><span class="classifier">numpy.array</span></dt><dd><p>prediction error matrix (k, k)</p>
</dd>
<dt><em>fs</em> = 1<span class="classifier">int</span></dt><dd><p>sampling rate</p>
</dd>
<dt><em>resolution</em> = 100<span class="classifier">int</span></dt><dd><p>number of spectrum data points</p>
</dd>
<dt><em>generalized</em> = False<span class="classifier">bool</span></dt><dd><p>generalized version or not</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>DTF</em><span class="classifier">numpy.array</span></dt><dd><p>matrix with estimation results (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] M. Kaminski, K.J. Blinowska. A new method of the description</p>
<blockquote>
<div><p>of the information flow. Biol.Cybern. 65:203-210, (1991).</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="connectivipy.conn.pdc_fun">
<span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">pdc_fun</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Acoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vcoef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#pdc_fun"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.pdc_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial Directed Coherence estimation from MVAR parameters.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>Acoef</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</p>
</dd>
<dt><em>Vcoef</em><span class="classifier">numpy.array</span></dt><dd><p>prediction error matrix (k, k)</p>
</dd>
<dt><em>fs</em> = 1<span class="classifier">int</span></dt><dd><p>sampling rate</p>
</dd>
<dt><em>resolution</em> = 100<span class="classifier">int</span></dt><dd><p>number of spectrum data points</p>
</dd>
<dt><em>generalized</em> = False<span class="classifier">bool</span></dt><dd><p>generalized version or not</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>PDC</em><span class="classifier">numpy.array</span></dt><dd><p>matrix with estimation results (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Sameshima, K., Baccala, L. A., Partial directed</p>
<blockquote>
<div><p>coherence: a new concept in neural structure determination.,
2001, Biol. Cybern. 84, 463–474.</p>
</div></blockquote>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.PartialCoh">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">PartialCoh</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#PartialCoh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.PartialCoh" title="Permalink to this definition">¶</a></dt>
<dd><p>PartialCoh - class inherits from <a class="reference internal" href="#connectivipy.conn.ConnectAR" title="connectivipy.conn.ConnectAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#connectivipy.conn.Connect.calculate" title="connectivipy.conn.Connect.calculate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.PartialCoh.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Acoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vcoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#PartialCoh.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.PartialCoh.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial Coherence estimation from MVAR parameters.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>Acoef</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</p>
</dd>
<dt><em>Vcoef</em><span class="classifier">numpy.array</span></dt><dd><p>prediction error matrix (k, k)</p>
</dd>
<dt><em>fs</em> = 1<span class="classifier">int</span></dt><dd><p>sampling rate</p>
</dd>
<dt><em>resolution</em> = 100<span class="classifier">int</span></dt><dd><p>number of spectrum data points</p>
</dd>
<dt><em>generalized</em> = False<span class="classifier">bool</span></dt><dd><p>generalized version or not</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>PC</em><span class="classifier">numpy.array</span></dt><dd><p>matrix with estimation results (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] G. M. Jenkins, D. G. Watts. Spectral Analysis and its</p>
<blockquote>
<div><p>Applications. Holden-Day, USA, 1969</p>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.PDC">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">PDC</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#PDC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.PDC" title="Permalink to this definition">¶</a></dt>
<dd><p>PDC - class inherits from <a class="reference internal" href="#connectivipy.conn.ConnectAR" title="connectivipy.conn.ConnectAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#connectivipy.conn.Connect.calculate" title="connectivipy.conn.Connect.calculate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.PDC.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Acoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vcoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#PDC.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.PDC.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>More in <a class="reference internal" href="#connectivipy.conn.pdc_fun" title="connectivipy.conn.pdc_fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdc_fun()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.gPDC">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">gPDC</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#gPDC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.gPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>gPDC - class inherits from <a class="reference internal" href="#connectivipy.conn.ConnectAR" title="connectivipy.conn.ConnectAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#connectivipy.conn.Connect.calculate" title="connectivipy.conn.Connect.calculate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.gPDC.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Acoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vcoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#gPDC.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.gPDC.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>More in <a class="reference internal" href="#connectivipy.conn.pdc_fun" title="connectivipy.conn.pdc_fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdc_fun()</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.DTF">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">DTF</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#DTF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.DTF" title="Permalink to this definition">¶</a></dt>
<dd><p>DTF - class inherits from <a class="reference internal" href="#connectivipy.conn.ConnectAR" title="connectivipy.conn.ConnectAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#connectivipy.conn.Connect.calculate" title="connectivipy.conn.Connect.calculate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.DTF.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Acoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vcoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#DTF.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.DTF.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>More in <a class="reference internal" href="#connectivipy.conn.dtf_fun" title="connectivipy.conn.dtf_fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">dtf_fun()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.gDTF">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">gDTF</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#gDTF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.gDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>gDTF - class inherits from <a class="reference internal" href="#connectivipy.conn.ConnectAR" title="connectivipy.conn.ConnectAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#connectivipy.conn.Connect.calculate" title="connectivipy.conn.Connect.calculate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.gDTF.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Acoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vcoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#gDTF.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.gDTF.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>More in <a class="reference internal" href="#connectivipy.conn.dtf_fun" title="connectivipy.conn.dtf_fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">dtf_fun()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.ffDTF">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">ffDTF</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#ffDTF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.ffDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>ffDTF - class inherits from <a class="reference internal" href="#connectivipy.conn.ConnectAR" title="connectivipy.conn.ConnectAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#connectivipy.conn.Connect.calculate" title="connectivipy.conn.Connect.calculate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.ffDTF.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Acoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vcoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#ffDTF.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.ffDTF.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>full-frequency Directed Transfer Function estimation from MVAR
parameters.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>Acoef</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</p>
</dd>
<dt><em>Vcoef</em><span class="classifier">numpy.array</span></dt><dd><p>prediction error matrix (k, k)</p>
</dd>
<dt><em>fs</em> = 1<span class="classifier">int</span></dt><dd><p>sampling rate</p>
</dd>
<dt><em>resolution</em> = 100<span class="classifier">int</span></dt><dd><p>number of spectrum data points</p>
</dd>
<dt><em>generalized</em> = False<span class="classifier">bool</span></dt><dd><p>generalized version or not</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>ffDTF</em><span class="classifier">numpy.array</span></dt><dd><p>matrix with estimation results (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Korzeniewska, A.et. all. Determination of information flow direction</p>
<blockquote>
<div><p>among brain structures by a modified directed transfer function (dDTF)
method. J. Neurosci. Methods 125, 195–207 (2003).</p>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.dDTF">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">dDTF</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#dDTF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.dDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>dDTF - class inherits from <a class="reference internal" href="#connectivipy.conn.ConnectAR" title="connectivipy.conn.ConnectAR"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#connectivipy.conn.Connect.calculate" title="connectivipy.conn.Connect.calculate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.dDTF.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Acoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Vcoef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#dDTF.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.dDTF.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>direct Directed Transfer Function estimation from MVAR
parameters. dDTF is a DTF multiplied in each frequency by
Patrial Coherence.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>Acoef</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</p>
</dd>
<dt><em>Vcoef</em><span class="classifier">numpy.array</span></dt><dd><p>prediction error matrix (k, k)</p>
</dd>
<dt><em>fs</em> = 1<span class="classifier">int</span></dt><dd><p>sampling rate</p>
</dd>
<dt><em>resolution</em> = 100<span class="classifier">int</span></dt><dd><p>number of spectrum data points</p>
</dd>
<dt><em>generalized</em> = False<span class="classifier">bool</span></dt><dd><p>generalized version or not</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>dDTF</em><span class="classifier">numpy.array</span></dt><dd><p>matrix with estimation results (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Korzeniewska, A.et. all. Determination of information flow direction</p>
<blockquote>
<div><p>among brain structures by a modified directed transfer function (dDTF)
method. J. Neurosci. Methods 125, 195–207 (2003).</p>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.Coherency">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">Coherency</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#Coherency"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.Coherency" title="Permalink to this definition">¶</a></dt>
<dd><p>Coherency - class inherits from <a class="reference internal" href="#connectivipy.conn.Connect" title="connectivipy.conn.Connect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connect</span></code></a> and overloads
<a class="reference internal" href="#connectivipy.conn.Connect.calculate" title="connectivipy.conn.Connect.calculate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.calculate()</span></code></a> method and <em>values_range</em> attribute.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.Coherency.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data</span></em>, <em class="sig-param"><span class="pre">cnfft=None</span></em>, <em class="sig-param"><span class="pre">cno=None</span></em>, <em class="sig-param"><span class="pre">window=&lt;function</span> <span class="pre">hanning&gt;</span></em>, <em class="sig-param"><span class="pre">im=False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#Coherency.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.Coherency.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Coherency calculation using FFT mehtod.
Args:</p>
<blockquote>
<div><dl>
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, N) where <em>k</em> is number of channels and
<em>N</em> is number of data points.</p>
</dd>
<dt><em>cnfft</em> = None<span class="classifier">int</span></dt><dd><p>number of data points in window; if None, it is N/5</p>
</dd>
<dt><em>cno</em> = 0<span class="classifier">int</span></dt><dd><p>overlap; if None, it is N/10</p>
</dd>
<dt><em>window</em> = np.hanning<span class="classifier">&lt;function&gt; generating window with 1 arg <em>n</em></span></dt><dd><p>window function</p>
</dd>
<dt><em>im</em> = False<span class="classifier">bool</span></dt><dd><p>if False it return absolute value, otherwise complex number</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>COH</em><span class="classifier">numpy.array</span></dt><dd><p>matrix with estimation results (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] M. B. Priestley Spectral Analysis and Time Series.</p>
<blockquote>
<div><p>Academic Press Inc. (London) LTD., 1981</p>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.PSI">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">PSI</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#PSI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.PSI" title="Permalink to this definition">¶</a></dt>
<dd><p>PSI - class inherits from <a class="reference internal" href="#connectivipy.conn.Connect" title="connectivipy.conn.Connect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connect</span></code></a> and overloads
<a class="reference internal" href="#connectivipy.conn.Connect.calculate" title="connectivipy.conn.Connect.calculate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.PSI.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data</span></em>, <em class="sig-param"><span class="pre">band_width=4</span></em>, <em class="sig-param"><span class="pre">psinfft=None</span></em>, <em class="sig-param"><span class="pre">psino=0</span></em>, <em class="sig-param"><span class="pre">window=&lt;function</span> <span class="pre">hanning&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#PSI.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.PSI.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase Slope Index calculation using FFT mehtod.
Args:</p>
<blockquote>
<div><dl>
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, N) where <em>k</em> is number of channels and
<em>N</em> is number of data points.</p>
</dd>
<dt><em>band_width</em> = 4<span class="classifier">int</span></dt><dd><p>width of frequency band where PSI values are summed</p>
</dd>
<dt><em>psinfft</em> = None<span class="classifier">int</span></dt><dd><p>number of data points in window; if None, it is N/5</p>
</dd>
<dt><em>psino</em> = 0<span class="classifier">int</span></dt><dd><p>overlap; if None, it is N/10</p>
</dd>
<dt><em>window</em> = np.hanning<span class="classifier">&lt;function&gt; generating window with 1 arg <em>n</em></span></dt><dd><p>window function</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>COH</em><span class="classifier">numpy.array</span></dt><dd><p>matrix with estimation results (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Nolte G. et all, Comparison of Granger Causality and</p>
<blockquote>
<div><p>Phase Slope Index. 267–276 (2009).</p>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="connectivipy.conn.GCI">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">connectivipy.conn.</span></span><span class="sig-name descname"><span class="pre">GCI</span></span><a class="reference internal" href="_modules/connectivipy/conn.html#GCI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.GCI" title="Permalink to this definition">¶</a></dt>
<dd><p>GCI - class inherits from <a class="reference internal" href="#connectivipy.conn.Connect" title="connectivipy.conn.Connect"><code class="xref py py-class docutils literal notranslate"><span class="pre">Connect</span></code></a> and overloads
<a class="reference internal" href="#connectivipy.conn.Connect.calculate" title="connectivipy.conn.Connect.calculate"><code class="xref py py-func docutils literal notranslate"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="py method">
<dt class="sig sig-object py" id="connectivipy.conn.GCI.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gcimethod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'yw'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gciorder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/connectivipy/conn.html#GCI.calculate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#connectivipy.conn.GCI.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Granger Causality Index calculation from MVAR model.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt><em>data</em><span class="classifier">numpy.array</span></dt><dd><p>array of shape (k, N) where <em>k</em> is number of channels and
<em>N</em> is number of data points.</p>
</dd>
<dt><em>gcimethod</em> = ‘yw’<span class="classifier">int</span></dt><dd><p>MVAR parameters estimation model</p>
</dd>
<dt><em>gciorder</em> = None<span class="classifier">int</span></dt><dd><p>model order, if None appropiate value is chosen basic
on default criterion</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt><em>gci</em><span class="classifier">numpy.array</span></dt><dd><p>matrix with estimation results (<em>resolution</em>, k, k)</p>
</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Nolte G. et all, Comparison of Granger Causality and</p>
<blockquote>
<div><p>Phase Slope Index. 267–276 (2009).</p>
</div></blockquote>
</dd></dl>

</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          
          <h3>Table of Contents</h3>
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="data.html">Data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Connectivity</a></li>
<li class="toctree-l1"><a class="reference internal" href="mvar.html">Mvarmodel</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Examples</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
            </form>
          </div>

        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="data.html" title="Data"
              >previous</a> |
            <a href="mvar.html" title="Mvarmodel"
              >next</a> |
            <a href="py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
              <br/>
              <a href="_sources/conn.rst.txt"
                rel="nofollow">Show Source</a>
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, Dominik Krzeminski.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>
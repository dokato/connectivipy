<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Connectvity &mdash; ConnectiviPy 0.36a documentation</title>
    
    <link rel="stylesheet" href="_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.36a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="ConnectiviPy 0.36a documentation" href="index.html" />
    <link rel="next" title="Mvarmodel" href="mvar.html" />
    <link rel="prev" title="Data" href="data.html" /> 
  </head>
  <body role="document">
    <div class="header-wrapper" role="banner">
      <div class="header">
          <p class="logo"><a href="index.html">
            <img class="logo" src="_static/connpy.png" alt="Logo"/>
          </a></p>
        <div class="headertitle"><a
          href="index.html">ConnectiviPy 0.36a documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="data.html" title="Data"
             accesskey="P">previous</a> |
          <a href="mvar.html" title="Mvarmodel"
             accesskey="N">next</a> |
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="connectvity">
<span id="conn"></span><h1>Connectvity<a class="headerlink" href="#connectvity" title="Permalink to this headline">¶</a></h1>
<p>Connectivity methods classes.</p>
<span class="target" id="module-conn"></span><dl class="function">
<dt id="conn.spectrum">
<code class="descclassname">conn.</code><code class="descname">spectrum</code><span class="sig-paren">(</span><em>acoef</em>, <em>vcoef</em>, <em>fs=1</em>, <em>resolution=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating data point from matrix <em>A</em> with MVAR coefficients.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>acoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</dd>
<dt><em>vcoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>prediction error matrix (k, k)</dd>
<dt><em>fs</em> = 1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>sampling rate</dd>
<dt><em>resolution</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spectrum data points</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>A_z</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>z-transformed A(f) complex matrix in shape (<em>resolution</em>, k, k)</dd>
<dt><em>H_z</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>inversion of <em>A_z</em></dd>
<dt><em>S_z</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>spectrum matrix (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] K. J. Blinowska, R. Kus, M. Kaminski (2004) “Granger causality</p>
<blockquote>
<div>and information flow in multivariate processes”
Physical Review E 70, 050902.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="conn.spectrum_inst">
<code class="descclassname">conn.</code><code class="descname">spectrum_inst</code><span class="sig-paren">(</span><em>acoef</em>, <em>vcoef</em>, <em>fs=1</em>, <em>resolution=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#spectrum_inst"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.spectrum_inst" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating data point from matrix <em>A</em> with MVAR coefficients taking
into account zero-lag effects.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>acoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, k, p+1) where <em>k</em> is number of channels and
<em>p</em> is a model order. acoef[0] - is (k, k) matrix for zero lag,
acoef[1] for one data point lag and so on.</dd>
<dt><em>vcoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>prediction error matrix (k, k)</dd>
<dt><em>fs</em> = 1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>sampling rate</dd>
<dt><em>resolution</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spectrum data points</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>A_z</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>z-transformed A(f) complex matrix in shape (<em>resolution</em>, k, k)</dd>
<dt><em>H_z</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>inversion of <em>A_z</em></dd>
<dt><em>S_z</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>spectrum matrix (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Erla S. et all, Multivariate Autoregressive Model with</p>
<blockquote>
<div>Instantaneous Effects to Improve Brain Connectivity Estimation, 
Int. J. Bioelectromagn. 11, 74–79 (2009).</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="conn.Connect">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">Connect</code><a class="reference internal" href="_modules/conn.html#Connect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.Connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class governing calculation of various connectivity estimators
with concrete methods: <em>short_time</em>, <em>significance</em> and
abstract <em>calculate</em>.</p>
<dl class="method">
<dt id="conn.Connect.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#Connect.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.Connect.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract method to calculate values of estimators from specific
parameters</p>
</dd></dl>

<dl class="method">
<dt id="conn.Connect.short_time">
<code class="descname">short_time</code><span class="sig-paren">(</span><em>data</em>, <em>nfft=None</em>, <em>no=None</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#Connect.short_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.Connect.short_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Short-tme version of estimator, where data is windowed into parts
of length <em>nfft</em> and overlap <em>no</em>. <em>params</em> catch additional
parameters specific for estimator.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>data matrix</dd>
<dt><em>nfft</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int </span></dt>
<dd>window length (if None it&#8217;s N/5)</dd>
<dt><em>no</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>overlap length (if None it&#8217;s N/10)</dd>
<dt><em>params</em> :</dt>
<dd>additional parameters specific for chosen estimator</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>stvalues</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>short time values (time points, frequency, k, k), where k
is number of channels</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="conn.Connect.short_time_significance">
<code class="descname">short_time_significance</code><span class="sig-paren">(</span><em>data</em>, <em>Nrep=10</em>, <em>alpha=0.05</em>, <em>nfft=None</em>, <em>no=None</em>, <em>verbose=True</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#Connect.short_time_significance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.Connect.short_time_significance" title="Permalink to this definition">¶</a></dt>
<dd><p>Significance of short-tme versions of estimators. It base on
bootstrap <a class="reference internal" href="#conn.Connect.bootstrap" title="conn.Connect.bootstrap"><code class="xref py py-func docutils literal"><span class="pre">Connect.bootstrap()</span></code></a> for multitrial case and 
surrogate data <a class="reference internal" href="#conn.Connect.surrogate" title="conn.Connect.surrogate"><code class="xref py py-func docutils literal"><span class="pre">Connect.surrogate()</span></code></a> for one trial.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>data matrix</dd>
<dt><em>Nrep</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of resamples</dd>
<dt><em>alpha</em> = 0.05 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>type I error rate (significance level)</dd>
<dt><em>nfft</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int </span></dt>
<dd>window length (if None it&#8217;s N/5)</dd>
<dt><em>no</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>overlap length (if None it&#8217;s N/10)</dd>
<dt><em>verbose</em> = True <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True it prints dot on every realization, if False it&#8217;s
quiet.</dd>
<dt><em>params</em> :</dt>
<dd>additional parameters specific for chosen estimator</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>signi_st</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>short time significance values in shape of
- (tp, k, k) for one sided estimator
- (tp, 2, k, k) for two sided
where k is number of channels and tp number of time points</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="conn.Connect.significance">
<code class="descname">significance</code><span class="sig-paren">(</span><em>data</em>, <em>Nrep=10</em>, <em>alpha=0.05</em>, <em>verbose=True</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#Connect.significance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.Connect.significance" title="Permalink to this definition">¶</a></dt>
<dd><p>Significance of connectivity estimators. It base on
bootstrap <a class="reference internal" href="#conn.Connect.bootstrap" title="conn.Connect.bootstrap"><code class="xref py py-func docutils literal"><span class="pre">Connect.bootstrap()</span></code></a> for multitrial case and 
surrogate data <a class="reference internal" href="#conn.Connect.surrogate" title="conn.Connect.surrogate"><code class="xref py py-func docutils literal"><span class="pre">Connect.surrogate()</span></code></a> for one trial.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>data matrix</dd>
<dt><em>Nrep</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of resamples</dd>
<dt><em>alpha</em> = 0.05 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>type I error rate (significance level)</dd>
<dt><em>verbose</em> = True <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True it prints dot on every realization, if False it&#8217;s
quiet.</dd>
<dt><em>params</em> :</dt>
<dd>additional parameters specific for chosen estimator</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>signific</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>significance values, check <a class="reference internal" href="#conn.Connect.levels" title="conn.Connect.levels"><code class="xref py py-func docutils literal"><span class="pre">Connect.levels()</span></code></a></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="conn.Connect.levels">
<code class="descname">levels</code><span class="sig-paren">(</span><em>signi</em>, <em>alpha</em>, <em>k</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#Connect.levels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.Connect.levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Levels of significance
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>signi</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>bootstraped values of each channel</dd>
<dt><em>alpha</em> <span class="classifier-delimiter">:</span> <span class="classifier">float </span></dt>
<dd>type I error rate (significance level) - from 0 to 1
- (1-<em>alpha</em>) for onesided estimators (e.g. class:<cite>DTF</cite>)
- <em>alpha</em> and (1-<em>alpha</em>) for twosided (e.g. class:<cite>PSI</cite>)</dd>
<dt><em>k</em> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of channels</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>ficance</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>maximal value throughout frequency of score at percentile
at level 1-<em>alpha</em>
- (k, k) for one sided estimator
- (2, k, k) for two sided</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="conn.Connect.bootstrap">
<code class="descname">bootstrap</code><span class="sig-paren">(</span><em>data</em>, <em>Nrep=100</em>, <em>alpha=0.05</em>, <em>verbose=True</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#Connect.bootstrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.Connect.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bootstrap - random sampling with replacement of trials.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>multichannel data matrix</dd>
<dt><em>Nrep</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of resamples</dd>
<dt><em>alpha</em> = 0.05 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>type I error rate (significance level)</dd>
<dt><em>verbose</em> = True <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True it prints dot on every realization, if False it&#8217;s
quiet.</dd>
<dt><em>params</em> :</dt>
<dd>additional parameters specific for chosen estimator</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>levelsigni</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>significance values, check <a class="reference internal" href="#conn.Connect.levels" title="conn.Connect.levels"><code class="xref py py-func docutils literal"><span class="pre">Connect.levels()</span></code></a></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="conn.Connect.surrogate">
<code class="descname">surrogate</code><span class="sig-paren">(</span><em>data</em>, <em>Nrep=100</em>, <em>alpha=0.05</em>, <em>verbose=True</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#Connect.surrogate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.Connect.surrogate" title="Permalink to this definition">¶</a></dt>
<dd><p>Surrogate data testing. Mixing data points in each channel.
Significance level in calculated over all <em>Nrep</em> surrogate sets.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>multichannel data matrix</dd>
<dt><em>Nrep</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of resamples</dd>
<dt><em>alpha</em> = 0.05 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>type I error rate (significance level)</dd>
<dt><em>verbose</em> = True <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True it prints dot on every realization, if False it&#8217;s
quiet.</dd>
<dt><em>params</em> :</dt>
<dd>additional parameters specific for chosen estimator</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>levelsigni</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>significance values, check <a class="reference internal" href="#conn.Connect.levels" title="conn.Connect.levels"><code class="xref py py-func docutils literal"><span class="pre">Connect.levels()</span></code></a></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.ConnectAR">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">ConnectAR</code><a class="reference internal" href="_modules/conn.html#ConnectAR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.ConnectAR" title="Permalink to this definition">¶</a></dt>
<dd><p>Inherits from <em>Connect</em> class and governs calculation of various
connectivity estimators basing on MVAR model methods. It overloads
<em>short_time</em>, <em>significance</em> methods but <em>calculate</em> remains abstract.</p>
<dl class="method">
<dt id="conn.ConnectAR.short_time">
<code class="descname">short_time</code><span class="sig-paren">(</span><em>data</em>, <em>nfft=None</em>, <em>no=None</em>, <em>mvarmethod='yw'</em>, <em>order=None</em>, <em>resol=None</em>, <em>fs=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#ConnectAR.short_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.ConnectAR.short_time" title="Permalink to this definition">¶</a></dt>
<dd><p>It overloads <a class="reference internal" href="#conn.ConnectAR" title="conn.ConnectAR"><code class="xref py py-class docutils literal"><span class="pre">ConnectAR</span></code></a> method <a class="reference internal" href="#conn.Connect.short_time" title="conn.Connect.short_time"><code class="xref py py-func docutils literal"><span class="pre">Connect.short_time()</span></code></a>.
Short-tme version of estimator, where data is windowed into parts
of length <em>nfft</em> and overlap <em>no</em>. <em>params</em> catch additional
parameters specific for estimator.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>data matrix</dd>
<dt><em>nfft</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int </span></dt>
<dd>window length (if None it&#8217;s N/5)</dd>
<dt><em>no</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>overlap length (if None it&#8217;s N/10)</dd>
<dt><em>mvarmethod</em> = &#8216;yw&#8217; :</dt>
<dd><blockquote class="first">
<div>MVAR parameters estimation method</div></blockquote>
<p class="last">all avaiable methods you can find in <em>fitting_algorithms</em></p>
</dd>
<dt><em>order</em> = None:</dt>
<dd>MVAR model order; it None, it is set automatically basing
on default criterion.</dd>
<dt><em>resol</em> = None:</dt>
<dd>frequency resolution; if None, it is 100.</dd>
<dt><em>fs</em> = 1 :</dt>
<dd>sampling frequency</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>stvalues</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>short time values (time points, frequency, k, k), where k
is number of channels</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="conn.ConnectAR.short_time_significance">
<code class="descname">short_time_significance</code><span class="sig-paren">(</span><em>data</em>, <em>Nrep=100</em>, <em>alpha=0.05</em>, <em>method='yw'</em>, <em>order=None</em>, <em>fs=1</em>, <em>resolution=None</em>, <em>nfft=None</em>, <em>no=None</em>, <em>verbose=True</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#ConnectAR.short_time_significance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.ConnectAR.short_time_significance" title="Permalink to this definition">¶</a></dt>
<dd><p>Significance of short-tme versions of estimators. It base on
bootstrap <a class="reference internal" href="#conn.ConnectAR.bootstrap" title="conn.ConnectAR.bootstrap"><code class="xref py py-func docutils literal"><span class="pre">ConnectAR.bootstrap()</span></code></a> for multitrial case and 
surrogate data <a class="reference internal" href="#conn.ConnectAR.surrogate" title="conn.ConnectAR.surrogate"><code class="xref py py-func docutils literal"><span class="pre">ConnectAR.surrogate()</span></code></a> for one trial.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>data matrix</dd>
<dt><em>Nrep</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of resamples</dd>
<dt><em>alpha</em> = 0.05 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>type I error rate (significance level)</dd>
<dt><em>method</em> = &#8216;yw&#8217;: str</dt>
<dd>method of MVAR parameters estimation
all avaiable methods you can find in <em>fitting_algorithms</em></dd>
<dt><em>order</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>MVAR model order, if None, it&#8217;s chosen using default criterion</dd>
<dt><em>fs</em> = 1 <span class="classifier-delimiter">:</span> <span class="classifier">int </span></dt>
<dd>sampling frequency</dd>
<dt><em>resolution</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int </span></dt>
<dd>resolution (if None, it&#8217;s 100 points)</dd>
<dt><em>nfft</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int </span></dt>
<dd>window length (if None it&#8217;s N/5)</dd>
<dt><em>no</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>overlap length (if None it&#8217;s N/10)</dd>
<dt><em>verbose</em> = True <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True it prints dot on every realization, if False it&#8217;s
quiet.</dd>
<dt><em>params</em> :</dt>
<dd>additional parameters specific for chosen estimator</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>signi_st</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>short time significance values in shape of
- (tp, k, k) for one sided estimator
- (tp, 2, k, k) for two sided
where k is number of channels and tp number of time points</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="conn.ConnectAR.significance">
<code class="descname">significance</code><span class="sig-paren">(</span><em>data</em>, <em>method</em>, <em>order=None</em>, <em>resolution=None</em>, <em>Nrep=10</em>, <em>alpha=0.05</em>, <em>verbose=True</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#ConnectAR.significance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.ConnectAR.significance" title="Permalink to this definition">¶</a></dt>
<dd><p>Significance of connectivity estimators. It base on
bootstrap <a class="reference internal" href="#conn.ConnectAR.bootstrap" title="conn.ConnectAR.bootstrap"><code class="xref py py-func docutils literal"><span class="pre">ConnectAR.bootstrap()</span></code></a> for multitrial case and 
surrogate data <a class="reference internal" href="#conn.ConnectAR.surrogate" title="conn.ConnectAR.surrogate"><code class="xref py py-func docutils literal"><span class="pre">ConnectAR.surrogate()</span></code></a> for one trial.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>data matrix</dd>
<dt><em>method</em> = &#8216;yw&#8217;: str</dt>
<dd>method of MVAR parametersestimation
all avaiable methods you can find in <em>fitting_algorithms</em></dd>
<dt><em>order</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>MVAR model order, if None, it&#8217;s chosen using default criterion</dd>
<dt><em>Nrep</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of resamples</dd>
<dt><em>alpha</em> = 0.05 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>type I error rate (significance level)</dd>
<dt><em>resolution</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int </span></dt>
<dd>resolution (if None, it&#8217;s 100 points)</dd>
<dt><em>verbose</em> = True <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True it prints dot on every realization, if False it&#8217;s
quiet.</dd>
<dt><em>params</em> :</dt>
<dd>additional parameters specific for chosen estimator</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>signi_st</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>significance values, check <a class="reference internal" href="#conn.Connect.levels" title="conn.Connect.levels"><code class="xref py py-func docutils literal"><span class="pre">Connect.levels()</span></code></a></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="conn.ConnectAR.bootstrap">
<code class="descname">bootstrap</code><span class="sig-paren">(</span><em>data</em>, <em>method</em>, <em>order=None</em>, <em>Nrep=10</em>, <em>alpha=0.05</em>, <em>fs=1</em>, <em>verbose=True</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#ConnectAR.bootstrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.ConnectAR.bootstrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bootstrap - random sampling with replacement of trials for <em>ConnectAR</em>.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>multichannel data matrix</dd>
<dt><em>method</em> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>method of MVAR parametersestimation
all avaiable methods you can find in <em>fitting_algorithms</em></dd>
<dt><em>Nrep</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of resamples</dd>
<dt><em>alpha</em> = 0.05 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>type I error rate (significance level)</dd>
<dt><em>order</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>MVAR model order, if None, it&#8217;s chosen using default criterion</dd>
<dt><em>verbose</em> = True <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True it prints dot on every realization, if False it&#8217;s
quiet.</dd>
<dt><em>params</em> :</dt>
<dd>additional parameters specific for chosen estimator</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>levelsigni</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>significance values, check <a class="reference internal" href="#conn.Connect.levels" title="conn.Connect.levels"><code class="xref py py-func docutils literal"><span class="pre">Connect.levels()</span></code></a></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="conn.ConnectAR.surrogate">
<code class="descname">surrogate</code><span class="sig-paren">(</span><em>data</em>, <em>method</em>, <em>Nrep=10</em>, <em>alpha=0.05</em>, <em>order=None</em>, <em>fs=1</em>, <em>verbose=True</em>, <em>**params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#ConnectAR.surrogate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.ConnectAR.surrogate" title="Permalink to this definition">¶</a></dt>
<dd><p>Surrogate data testing for <em>ConnectAR</em> . Mixing data points in each channel.
Significance level in calculated over all <em>Nrep</em> surrogate sets.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>multichannel data matrix</dd>
<dt><em>method</em> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>method of MVAR parameters estimation
all avaiable methods you can find in <em>fitting_algorithms</em></dd>
<dt><em>Nrep</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of resamples</dd>
<dt><em>alpha</em> = 0.05 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>type I error rate (significance level)</dd>
<dt><em>order</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>MVAR model order, if None, it&#8217;s chosen using default criterion</dd>
<dt><em>verbose</em> = True <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True it prints dot on every realization, if False it&#8217;s
quiet.</dd>
<dt><em>params</em> :</dt>
<dd>additional parameters specific for chosen estimator</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>levelsigni</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>significance values, check <a class="reference internal" href="#conn.Connect.levels" title="conn.Connect.levels"><code class="xref py py-func docutils literal"><span class="pre">Connect.levels()</span></code></a></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="conn.dtf_fun">
<code class="descclassname">conn.</code><code class="descname">dtf_fun</code><span class="sig-paren">(</span><em>Acoef</em>, <em>Vcoef</em>, <em>fs</em>, <em>resolution</em>, <em>generalized=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#dtf_fun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.dtf_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Directed Transfer Function estimation from MVAR parameters.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>Acoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</dd>
<dt><em>Vcoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>prediction error matrix (k, k)</dd>
<dt><em>fs</em> = 1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>sampling rate</dd>
<dt><em>resolution</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spectrum data points</dd>
<dt><em>generalized</em> = False <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>generalized version or not</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>DTF</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>matrix with estimation results (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] M. Kaminski, K.J. Blinowska. A new method of the description</p>
<blockquote>
<div>of the information flow. Biol.Cybern. 65:203-210, (1991).</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="conn.pdc_fun">
<code class="descclassname">conn.</code><code class="descname">pdc_fun</code><span class="sig-paren">(</span><em>Acoef</em>, <em>Vcoef</em>, <em>fs</em>, <em>resolution</em>, <em>generalized=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#pdc_fun"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.pdc_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial Directed Coherence estimation from MVAR parameters.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>Acoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</dd>
<dt><em>Vcoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>prediction error matrix (k, k)</dd>
<dt><em>fs</em> = 1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>sampling rate</dd>
<dt><em>resolution</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spectrum data points</dd>
<dt><em>generalized</em> = False <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>generalized version or not</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>PDC</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>matrix with estimation results (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Sameshima, K., Baccala, L. A., Partial directed</p>
<blockquote>
<div>coherence: a new concept in neural structure determination.,
2001, Biol. Cybern. 84, 463–474.</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="conn.PartialCoh">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">PartialCoh</code><a class="reference internal" href="_modules/conn.html#PartialCoh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.PartialCoh" title="Permalink to this definition">¶</a></dt>
<dd><p>PartialCoh - class inherits from <a class="reference internal" href="#conn.ConnectAR" title="conn.ConnectAR"><code class="xref py py-class docutils literal"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.PartialCoh.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>Acoef=None</em>, <em>Vcoef=None</em>, <em>fs=None</em>, <em>resolution=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#PartialCoh.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.PartialCoh.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial Coherence estimation from MVAR parameters.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>Acoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</dd>
<dt><em>Vcoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>prediction error matrix (k, k)</dd>
<dt><em>fs</em> = 1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>sampling rate</dd>
<dt><em>resolution</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spectrum data points</dd>
<dt><em>generalized</em> = False <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>generalized version or not</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>PC</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>matrix with estimation results (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] G. M. Jenkins, D. G. Watts. Spectral Analysis and its</p>
<blockquote>
<div>Applications. Holden-Day, USA, 1969</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.PDC">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">PDC</code><a class="reference internal" href="_modules/conn.html#PDC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.PDC" title="Permalink to this definition">¶</a></dt>
<dd><p>PDC - class inherits from <a class="reference internal" href="#conn.ConnectAR" title="conn.ConnectAR"><code class="xref py py-class docutils literal"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.PDC.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>Acoef=None</em>, <em>Vcoef=None</em>, <em>fs=None</em>, <em>resolution=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#PDC.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.PDC.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>More in <a class="reference internal" href="#conn.pdc_fun" title="conn.pdc_fun"><code class="xref py py-func docutils literal"><span class="pre">pdc_fun()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.gPDC">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">gPDC</code><a class="reference internal" href="_modules/conn.html#gPDC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.gPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>gPDC - class inherits from <a class="reference internal" href="#conn.ConnectAR" title="conn.ConnectAR"><code class="xref py py-class docutils literal"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.gPDC.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>Acoef=None</em>, <em>Vcoef=None</em>, <em>fs=None</em>, <em>resolution=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#gPDC.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.gPDC.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>More in <a class="reference internal" href="#conn.pdc_fun" title="conn.pdc_fun"><code class="xref py py-func docutils literal"><span class="pre">pdc_fun()</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.DTF">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">DTF</code><a class="reference internal" href="_modules/conn.html#DTF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.DTF" title="Permalink to this definition">¶</a></dt>
<dd><p>DTF - class inherits from <a class="reference internal" href="#conn.ConnectAR" title="conn.ConnectAR"><code class="xref py py-class docutils literal"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.DTF.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>Acoef=None</em>, <em>Vcoef=None</em>, <em>fs=None</em>, <em>resolution=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#DTF.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.DTF.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>More in <a class="reference internal" href="#conn.dtf_fun" title="conn.dtf_fun"><code class="xref py py-func docutils literal"><span class="pre">dtf_fun()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.gDTF">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">gDTF</code><a class="reference internal" href="_modules/conn.html#gDTF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.gDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>gDTF - class inherits from <a class="reference internal" href="#conn.ConnectAR" title="conn.ConnectAR"><code class="xref py py-class docutils literal"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.gDTF.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>Acoef=None</em>, <em>Vcoef=None</em>, <em>fs=None</em>, <em>resolution=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#gDTF.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.gDTF.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>More in <a class="reference internal" href="#conn.dtf_fun" title="conn.dtf_fun"><code class="xref py py-func docutils literal"><span class="pre">dtf_fun()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.ffDTF">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">ffDTF</code><a class="reference internal" href="_modules/conn.html#ffDTF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.ffDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>ffDTF - class inherits from <a class="reference internal" href="#conn.ConnectAR" title="conn.ConnectAR"><code class="xref py py-class docutils literal"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.ffDTF.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>Acoef=None</em>, <em>Vcoef=None</em>, <em>fs=None</em>, <em>resolution=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#ffDTF.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.ffDTF.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>full-frequency Directed Transfer Function estimation from MVAR
parameters.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>Acoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</dd>
<dt><em>Vcoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>prediction error matrix (k, k)</dd>
<dt><em>fs</em> = 1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>sampling rate</dd>
<dt><em>resolution</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spectrum data points</dd>
<dt><em>generalized</em> = False <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>generalized version or not</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>ffDTF</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>matrix with estimation results (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Korzeniewska, A.et. all. Determination of information flow direction</p>
<blockquote>
<div>among brain structures by a modified directed transfer function (dDTF) 
method. J. Neurosci. Methods 125, 195–207 (2003).</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.dDTF">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">dDTF</code><a class="reference internal" href="_modules/conn.html#dDTF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.dDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>dDTF - class inherits from <a class="reference internal" href="#conn.ConnectAR" title="conn.ConnectAR"><code class="xref py py-class docutils literal"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.dDTF.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>Acoef=None</em>, <em>Vcoef=None</em>, <em>fs=None</em>, <em>resolution=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#dDTF.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.dDTF.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>direct Directed Transfer Function estimation from MVAR
parameters. dDTF is a DTF multiplied in each frequency by
Patrial Coherence.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>Acoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, k, p) where <em>k</em> is number of channels and
<em>p</em> is a model order.</dd>
<dt><em>Vcoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>prediction error matrix (k, k)</dd>
<dt><em>fs</em> = 1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>sampling rate</dd>
<dt><em>resolution</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spectrum data points</dd>
<dt><em>generalized</em> = False <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>generalized version or not</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>dDTF</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>matrix with estimation results (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Korzeniewska, A.et. all. Determination of information flow direction</p>
<blockquote>
<div>among brain structures by a modified directed transfer function (dDTF) 
method. J. Neurosci. Methods 125, 195–207 (2003).</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.iPDC">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">iPDC</code><a class="reference internal" href="_modules/conn.html#iPDC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.iPDC" title="Permalink to this definition">¶</a></dt>
<dd><p>iPDC - class inherits from <a class="reference internal" href="#conn.ConnectAR" title="conn.ConnectAR"><code class="xref py py-class docutils literal"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.iPDC.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>Acoef=None</em>, <em>Vcoef=None</em>, <em>fs=None</em>, <em>resolution=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#iPDC.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.iPDC.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>instantaneous Partial Directed Coherence  from MVAR
parameters.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>Acoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, k, p+1) where <em>k</em> is number of channels and
<em>p</em> is a model order. It&#8217;s zero lag case.</dd>
<dt><em>Vcoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>prediction error matrix (k, k)</dd>
<dt><em>fs</em> = 1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>sampling rate</dd>
<dt><em>resolution</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spectrum data points</dd>
<dt><em>generalized</em> = False <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>generalized version or not</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>iPDC</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>matrix with estimation results (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Erla, S. et all Multivariate Autoregressive Model with Instantaneous</p>
<blockquote>
<div>Effects to Improve Brain Connectivity Estimation. 
Int. J. Bioelectromagn. 11, 74–79 (2009).</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.iDTF">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">iDTF</code><a class="reference internal" href="_modules/conn.html#iDTF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.iDTF" title="Permalink to this definition">¶</a></dt>
<dd><p>iDTF - class inherits from <a class="reference internal" href="#conn.ConnectAR" title="conn.ConnectAR"><code class="xref py py-class docutils literal"><span class="pre">ConnectAR</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.iDTF.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>Acoef=None</em>, <em>Vcoef=None</em>, <em>fs=None</em>, <em>resolution=100</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#iDTF.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.iDTF.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>instantaneous Partial Directed Coherence  from MVAR
parameters.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>Acoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, k, p+1) where <em>k</em> is number of channels and
<em>p</em> is a model order. It&#8217;s zero lag case.</dd>
<dt><em>Vcoef</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>prediction error matrix (k, k)</dd>
<dt><em>fs</em> = 1 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>sampling rate</dd>
<dt><em>resolution</em> = 100 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of spectrum data points</dd>
<dt><em>generalized</em> = False <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>generalized version or not</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>iPDC</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>matrix with estimation results (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Erla, S. et all, Multivariate Autoregressive Model with Instantaneous</p>
<blockquote>
<div>Effects to Improve Brain Connectivity Estimation. 
Int. J. Bioelectromagn. 11, 74–79 (2009).</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.Coherency">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">Coherency</code><a class="reference internal" href="_modules/conn.html#Coherency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.Coherency" title="Permalink to this definition">¶</a></dt>
<dd><p>Coherency - class inherits from <a class="reference internal" href="#conn.Connect" title="conn.Connect"><code class="xref py py-class docutils literal"><span class="pre">Connect</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method and <em>values_range</em> attribute.</p>
<dl class="method">
<dt id="conn.Coherency.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>data</em>, <em>cnfft=None</em>, <em>cno=None</em>, <em>window=&lt;function hanning at 0x0000000003DC75F8&gt;</em>, <em>im=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#Coherency.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.Coherency.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Coherency calculation using FFT mehtod.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, N) where <em>k</em> is number of channels and
<em>N</em> is number of data points.</dd>
<dt><em>cnfft</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of data points in window; if None, it is N/5</dd>
<dt><em>cno</em> = 0 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>overlap; if None, it is N/10</dd>
<dt><em>window</em> = np.hanning <span class="classifier-delimiter">:</span> <span class="classifier">&lt;function&gt; generating window with 1 arg <em>n</em></span></dt>
<dd>window function</dd>
<dt><em>im</em> = False <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if False it return absolute value, otherwise complex number</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>COH</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>matrix with estimation results (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] M. B. Priestley Spectral Analysis and Time Series.</p>
<blockquote>
<div>Academic Press Inc. (London) LTD., 1981</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.PSI">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">PSI</code><a class="reference internal" href="_modules/conn.html#PSI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.PSI" title="Permalink to this definition">¶</a></dt>
<dd><p>PSI - class inherits from <a class="reference internal" href="#conn.Connect" title="conn.Connect"><code class="xref py py-class docutils literal"><span class="pre">Connect</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.PSI.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>data</em>, <em>band_width=4</em>, <em>psinfft=None</em>, <em>psino=0</em>, <em>window=&lt;function hanning at 0x0000000003DC75F8&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#PSI.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.PSI.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase Slope Index calculation using FFT mehtod.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, N) where <em>k</em> is number of channels and
<em>N</em> is number of data points.</dd>
<dt><em>band_width</em> = 4 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>width of frequency band where PSI values are summed</dd>
<dt><em>psinfft</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of data points in window; if None, it is N/5</dd>
<dt><em>psino</em> = 0 <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>overlap; if None, it is N/10</dd>
<dt><em>window</em> = np.hanning <span class="classifier-delimiter">:</span> <span class="classifier">&lt;function&gt; generating window with 1 arg <em>n</em></span></dt>
<dd>window function</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>COH</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>matrix with estimation results (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Nolte G. et all, Comparison of Granger Causality and</p>
<blockquote>
<div>Phase Slope Index. 267–276 (2009).</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="conn.GCI">
<em class="property">class </em><code class="descclassname">conn.</code><code class="descname">GCI</code><a class="reference internal" href="_modules/conn.html#GCI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.GCI" title="Permalink to this definition">¶</a></dt>
<dd><p>GCI - class inherits from <a class="reference internal" href="#conn.Connect" title="conn.Connect"><code class="xref py py-class docutils literal"><span class="pre">Connect</span></code></a> and overloads
<a class="reference internal" href="#conn.Connect.calculate" title="conn.Connect.calculate"><code class="xref py py-func docutils literal"><span class="pre">Connect.calculate()</span></code></a> method.</p>
<dl class="method">
<dt id="conn.GCI.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>data</em>, <em>gcimethod='yw'</em>, <em>gciorder=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/conn.html#GCI.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#conn.GCI.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Granger Causality Index calculation from MVAR model.
Args:</p>
<blockquote>
<div><dl class="docutils">
<dt><em>data</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>array of shape (k, N) where <em>k</em> is number of channels and
<em>N</em> is number of data points.</dd>
<dt><em>gcimethod</em> = &#8216;yw&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>MVAR parameters estimation model</dd>
<dt><em>gciorder</em> = None <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>model order, if None appropiate value is chosen basic
on default criterion</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt><em>gci</em> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.array</span></dt>
<dd>matrix with estimation results (<em>resolution</em>, k, k)</dd>
</dl>
</dd>
</dl>
<p>References:
.. [1] Nolte G. et all, Comparison of Granger Causality and</p>
<blockquote>
<div>Phase Slope Index. 267–276 (2009).</div></blockquote>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="data.html">Data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Connectvity</a></li>
<li class="toctree-l1"><a class="reference internal" href="mvar.html">Mvarmodel</a></li>
<li class="toctree-l1"><a class="reference internal" href="plot.html">Plot</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorials</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
            </form>
            <p class="searchtip" style="font-size: 90%">
                Enter search terms or a module, class or function name.
            </p>
          </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="data.html" title="Data"
              >previous</a> |
            <a href="mvar.html" title="Mvarmodel"
              >next</a> |
            <a href="py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
              <br/>
              <a href="_sources/conn.txt"
                rel="nofollow">Show Source</a>
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Dominik Krzeminski.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3b2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>